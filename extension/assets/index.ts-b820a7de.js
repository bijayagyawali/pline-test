var U=Object.defineProperty;var C=(i,e,a)=>e in i?U(i,e,{enumerable:!0,configurable:!0,writable:!0,value:a}):i[e]=a;var b=(i,e,a)=>(C(i,typeof e!="symbol"?e+"":e,a),a);import{S as l,e as k,a as g,P as w}from"./env_config-ed3c2686.js";function d(i,{data:e,receivers:a,isResponse:s}){const t={version:"v1",data:e,isResponse:s,party:{receivers:a,sender:l.background}};return i.postMessage(t)}const P="/assets/index.tsx-loader-c236749f.js",T=k.baseUrl+"/v1";async function E(i,e,a={}){const{body:s,signal:t}=a;try{const o={Accept:"application/json"};(e==="POST"||e==="PUT")&&(o["Content-Type"]="application/json");const n={method:e,headers:o,body:JSON.stringify(s),signal:t},r=await fetch(i,n);if(!r.ok)throw new Error(`${r.status} ${r.statusText}`);return await r.json()}catch(o){throw o instanceof SyntaxError?new Error(`There was a SyntaxError: ${o.message}`):t&&t.aborted?new Error("Request aborted"):new Error(`Failed to fetch data from ${i}: ${o.message}`)}}async function S(i,e={}){const a=`${T}${i}`;return E(a,"GET",e)}async function A(i,e,a={}){const s=`${T}${i}`;return E(s,"POST",{body:e,...a})}const u=k.cookie;class M{constructor(e,a,s){b(this,"messageHandler");b(this,"tabUrlUpdateHandler");b(this,"extensionIconClickHandler");b(this,"globalState",{tabs:{},popupPort:null,errors:new Set,auth:g});b(this,"cookies",{accessToken:null,anonymousToken:null});this.messageHandler=e,this.tabUrlUpdateHandler=a,this.extensionIconClickHandler=s,chrome.runtime.setUninstallURL("https://www.pline.io/pline-uninstalled/"),chrome.runtime.onInstalled.addListener(async()=>{(await chrome.tabs.query({})).forEach(o=>{o.id&&o.url&&!this.isBrowserPage(o.url)&&chrome.scripting.executeScript({target:{tabId:o.id},files:[P]}).then(()=>this.addNewTabInGlobalState(o)).catch(n=>{})})}),chrome.action.onClicked.addListener(this.onExtensionIconClick.bind(this)),chrome.tabs.onCreated.addListener(this.onTabCreate.bind(this)),chrome.tabs.onUpdated.addListener(this.onTabUpdate.bind(this)),chrome.tabs.onRemoved.addListener(this.onTabRemove.bind(this)),chrome.runtime.onConnect.addListener(t=>{t.name===w&&(this.onPortConnect(t),t.onMessage.addListener(this.onPortMessage.bind(this)),t.onDisconnect.addListener(this.onPortDisconnect.bind(this)))}),chrome.cookies.getAll({domain:u.domain},t=>{let o=null,n=null;for(let c=0;c<t.length;c++){const p=t[c];p.domain===u.domain&&(p.name===u.name?o=p:p.name===u.anonymous.name&&(n=p))}const r=this.globalState.auth;o||n?(r.hasAuthCookie=!0,this.cookies.accessToken=o,this.cookies.anonymousToken=n,o&&n?this.syncAnonymousUserAsync():this.populateUserDataAsync()):(this.globalState.auth=g,this.createAnonymousUserAsync())}),chrome.cookies.onChanged.addListener(({cookie:t,removed:o})=>{if(t.domain!==u.domain||t.name!==u.name&&t.name!==u.anonymous.name)return;const n=this.globalState.auth;t.name===u.name?o?(this.cookies.accessToken=null,this.checkToken({hasTokenCB:()=>this.populateUserDataAsync(!0),hasNoTokenCB:()=>{this.globalState.auth=g,this.sendAuthSyncMessage(),this.createAnonymousUserAsync(!0)}})):(this.cookies.accessToken=t,n.hasAuthCookie?n.me?n.me.isAnonymous&&this.syncAnonymousUserAsync(!0):this.populateUserDataAsync(!0):(this.globalState.auth={hasAuthCookie:!0},this.sendAuthSyncMessage(),this.populateUserDataAsync(!0))):t.name===u.anonymous.name&&(o?(this.cookies.anonymousToken=null,this.checkToken({hasTokenCB:()=>this.populateUserDataAsync(!0),hasNoTokenCB:()=>{this.globalState.auth=g,this.sendAuthSyncMessage(),this.createAnonymousUserAsync(!0)}})):(this.cookies.anonymousToken=t,n.hasAuthCookie&&n.me&&!n.me.isAnonymous||this.populateUserDataAsync(!0)))})}isBrowserPage(e){return e.startsWith("chrome://")}isSentFromTab(e){var a,s,t;return!!((a=e.sender)!=null&&a.tab&&((t=(s=e.sender)==null?void 0:s.tab)!=null&&t.id))}addNewTabInGlobalState(e){const a=e.id;if(!a)throw new Error("Tab created with no id");let s,t=!1;e.url&&this.isBrowserPage(e.url)?(t=!0,s={mode:"AUTOMATION",code:"browser-page",data:null}):s={mode:"AUTOMATION",code:"pick-mode",data:null};let o=chrome.tabs.connect(a,{name:w});return o.sender?(o.onMessage.addListener(this.onPortMessage.bind(this)),o.onDisconnect.addListener(this.onPortDisconnect.bind(this))):(o.disconnect(),o=null),this.globalState.tabs[a]={id:a,state:s,_tab:e,port:o,isBrowserPage:t,isLoading:e.status==="loading"},this.globalState.tabs[a]}sendAuthSyncMessage(e=!1){const a={query:"auth-sync",payload:this.globalState.auth};this.globalState.popupPort&&d(this.globalState.popupPort,{data:a,isResponse:e,receivers:[l.popup]}),Object.values(this.globalState.tabs).forEach(s=>{s.port&&d(s.port,{data:a,isResponse:e,receivers:[l.content,l.mainContent,l.popupContent]})})}async createAnonymousUserAsync(e=!1){try{await A("/auth/register-anonymous",{}),this.globalState.errors.delete("AuthError")}catch{this.globalState.errors.add("AuthError"),this.globalState.auth={hasAuthCookie:!1,hasError:"AuthError"}}finally{e&&this.sendAuthSyncMessage()}}async populateUserDataAsync(e=!1){var a,s;try{const t=((a=this.cookies.accessToken)==null?void 0:a.value)||((s=this.cookies.anonymousToken)==null?void 0:s.value);if(!t)throw new Error("No auth cookie found.");const o=await S("/users/me"),{organisation:n}=await S("/organisations/me");this.globalState.errors.delete("AuthMeError"),this.globalState.auth={me:o,organisation:n,hasAuthCookie:!0,jwt:t}}catch{this.globalState.errors.add("AuthMeError"),this.globalState.auth={hasAuthCookie:!1,hasError:"AuthMeError"}}finally{e&&this.sendAuthSyncMessage()}}async syncAnonymousUserAsync(e=!1){try{await A("/auth/sync-anonymous",{}),await this.populateUserDataAsync(),this.globalState.errors.delete("AuthSyncError")}catch{this.globalState.errors.add("AuthSyncError"),this.globalState.auth={hasAuthCookie:!1,hasError:"AuthSyncError"}}finally{e&&this.sendAuthSyncMessage()}}async checkToken({hasTokenCB:e,hasNoTokenCB:a}){const s=await chrome.cookies.getAll({domain:u.domain}),t=s.find(n=>n.domain===u.domain&&n.name===u.name),o=s.find(n=>n.domain===u.domain&&n.name===u.anonymous.name);return t||o?e&&e():a&&a()}onExtensionIconClick(e){if(!e.id)return;let a=this.globalState.tabs[e.id];a||(a=this.addNewTabInGlobalState(e)),a.port&&this.extensionIconClickHandler({tab:a})}onTabCreate(e){this.addNewTabInGlobalState(e)}onTabUpdate(e,a,s){let t=this.globalState.tabs[e];if(t||(t=this.addNewTabInGlobalState(s)),a.status==="loading"){if(t.isLoading=!0,a.url&&a.url!==t._tab.url){const n=t._tab.url,r=a.url,c=p=>(t.state=p,t.state);this.isBrowserPage(r)?(t.isBrowserPage=!0,t.state={mode:"AUTOMATION",code:"browser-page",data:null}):(t.state.code==="browser-page"&&(t.state={mode:"AUTOMATION",code:"pick-mode",data:null}),t.isBrowserPage=!1),this.tabUrlUpdateHandler({oldUrl:n,newUrl:r,state:t.state,isBrowserPage:t.isBrowserPage,utils:{updateState:c,isBrowserPage:this.isBrowserPage}})}}else t.isLoading=!1;t._tab=s}onTabRemove(e){this.globalState.tabs[e],delete this.globalState.tabs[e]}onPortConnect(e){if(this.isSentFromTab(e)){const a=e.sender.tab.id;let s=this.globalState.tabs[a];s||(s=this.addNewTabInGlobalState(e.sender.tab)),s.port=e}else this.globalState.popupPort=e}async onPortDisconnect(e){if(this.isSentFromTab(e)){const a=e.sender.tab.id;let s=this.globalState.tabs[a];s||(s=this.addNewTabInGlobalState(e.sender.tab)),s.port=null}else this.globalState.popupPort=null}async onPortMessage(e,a){const s=this.isSentFromTab(a);let t;if(e.party.sender===l.content||e.party.sender===l.mainContent||e.party.sender===l.popupContent)if(s)t=a.sender.tab.id;else throw new Error("Message sent as 'content' but not from a tab");else if(e.party.sender===l.popup)t=e.party.tabId;else throw e.party.sender===l.background?new Error("Message sent as 'background' to background script"):new Error(`Unknown message sender: ${e.party}`);let o=this.globalState.tabs[t];if(!o)if(s)o=this.addNewTabInGlobalState(a.sender.tab);else{const c=await chrome.tabs.get(t);o=this.addNewTabInGlobalState(c)}const n=c=>(o.state=c,o.state),r=async()=>{const c=this.globalState.auth;return c.hasError&&(c.hasError==="AuthError"?await this.createAnonymousUserAsync():c.hasError==="AuthMeError"?await this.populateUserDataAsync():c.hasError==="AuthSyncError"&&await this.syncAnonymousUserAsync()),this.globalState.auth};this.messageHandler({message:e,tabDetail:o,updateTabState:n,retryAuthentication:r,auth:this.globalState.auth,popupPort:this.globalState.popupPort})}}function I(i){return async e=>{const{message:a,tabDetail:s,popupPort:t}=e,{party:o}=a,n=o.receivers.reduce((r,c)=>(c==="popup"?r.popup=!0:c==="content"||c==="mainContent"||c==="popupContent"?r.content=!0:c==="background"&&(r.background=!0),r),{popup:!1,content:!1,background:!1});n.background&&await i(e),n.popup&&t&&t.postMessage(a),n.content&&s.port&&s.port.postMessage(a)}}new M(I(N),v,D);async function N(i){const{auth:e,message:a,tabDetail:s,popupPort:t,updateTabState:o,retryAuthentication:n}=i,{sender:r}=a.party,{query:c,payload:p}=a.data,f=r===l.popup,m=r===l.content||r===l.mainContent||r===l.popupContent;switch(c){case"sync-request":{let h;if(f){if(!t)throw new Error("No popup connected");h=t}else if(m){if(!s.port)throw new Error("No content script connected");h=s.port}else throw new Error("Message sent as 'background' to background script");d(h,{data:{query:"sync",payload:{state:s.state,isLoading:s.isLoading}},isResponse:!0,receivers:[r]});break}case"update-tab-info":{const y={query:"sync",payload:{state:o(p),isLoading:s.isLoading}};s.port&&d(s.port,{data:y,isResponse:!0,receivers:[l.content]}),t&&d(t,{data:y,isResponse:!0,receivers:[l.popup]});break}case"active-tab-request":{let h;if(f){if(!t)throw new Error("No popup connected");h=t}else if(m){if(!s.port)throw new Error("No content script connected");h=s.port}else throw new Error("Message sent as 'background' to background script");d(h,{data:{query:"active-tab",payload:s},isResponse:!0,receivers:[r]});break}case"heartbeat":{if(!s.port)throw new Error("No content script connected");d(s.port,{data:{query:"heartbeat",payload:null},isResponse:!0,receivers:[l.content]});break}case"auth-sync-request":{let h;if(f){if(!t)throw new Error("No popup connected");h=t}else if(m){if(!s.port)throw new Error("No content script connected");h=s.port}else throw new Error("Message sent as 'background' to background script");d(h,{data:{query:"auth-sync",payload:e},isResponse:!0,receivers:[r]});break}case"auth-retry":{const y={query:"auth-sync",payload:await n()};s.port&&d(s.port,{data:y,isResponse:!0,receivers:[l.content,l.mainContent,l.popupContent]}),t&&d(t,{data:y,isResponse:!0,receivers:[l.popup]});break}default:throw new Error("Invalid query sent to background service worker")}}async function v(i){const{oldUrl:e,state:a,newUrl:s,utils:{updateState:t,isBrowserPage:o}}=i;let n;o(s)?n={mode:a.mode,code:"browser-page",data:null}:a.code==="browser-page"||e&&o(e)?n={mode:a.mode,code:"pick-mode",data:null}:n=a,t(n)}function D(i){const e=i.tab;e.port&&d(e.port,{data:{query:"toggle-popup",payload:null},receivers:[l.content]})}
